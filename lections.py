# Вот некоторые из основных классов и структур данных, доступных в Python:

#     int: Класс для целых чисел.
    
#     float: Класс для чисел с плавающей точкой.

#     str: Класс для строковых значений (текст).

#     list: [] Класс для списков, упорядоченных коллекций элементов.
    
#     tuple: () Класс для кортежей, неизменяемых упорядоченных коллекций элементов.

#     dict: {} Класс для словарей, коллекций, состоящих из пар ключ-значение.
    
#     set: {} Класс для множеств, неупорядоченных коллекций уникальных элементов.
    
#     bool: Класс для логических значений True и False.

#     NoneType: Класс для None, представляющего отсутствие значения.   

#=========================================================

# n = (0,1,2)

# a = 10
# b = 5
# c = 2

# print(n) --- варианты вывода переменной

# print(f'n = {n}') 

# print("{} - {} - {}".format(a,b,c))

# print(type(n)) ---   вывод типа данных переменной

# print('Ввести первое число: ')
# a = int(input())
# b = int(input('Ввести второе число: '))
# print(a + b) #ответ 3

# class(input())

#=========================================================

# Округление:  
# a = 5.8908002374
# b = 6.342
# print(a * b)
# print(round(a * b, 3))  # 3 - три знака после запятой ,

#=========================================================

# 123 % 10 = 3
# 123 % 100 = 23
# 123 % 1000 = 123

# 123 / 10 = 12
# 123 / 100 = 1
# 123 / 1000 = 0

#=========================================================

# if elif else
    #Например: 
# x = 10

# if x < 0:
#     print("x отрицательное число")
# elif x == 0:
#     print("x равно нулю")
# else:
#     print("x положительное число")

#=========================================================

# Арифметические операции

#   Знак операции Операция
#   + Сложение
#   - Вычитание
#   * Умножение
#    / Деление (по умолчанию в вещественных числах)
#   % Остаток от деления
#   // Целочисленное деление
#   ** Возведение в степень

#=========================================================

# Логические операции

    #   Знак операции Операция
    #   > Больше
    #   >= Больше или равно
    #   < Меньше
    #   <= Меньше или равно
    #   == Равно (проверяет, равны ли числа)
    #   != Не равно (проверяет, не равны ли значения)
    #   not Не (отрицание)
    #   and И (конъюнкция)
    #   or Или (дизъюнкция)

#=========================================================

# Пример программного кода без использования break:

    #   n = 423
    #   summa = 0
    #   while n > 0:
    #       x = n % 10
    #       summa = summa + x
    #       n = n // 10
    #   else:
    #   print('Пожалуй')
    #   print('хватит )')
    #   print(summa)
    #   # Пожалуй
    #   # хватит )
    #   # 9

#=========================================================
'''
В Python цикл for в основном используется для перебора значений
Пример использования цикла for:
for i in enumeration:
# operator 1
# operator 2
# ...
# operator n
for i in 1, -2, 3, 14, 5:
print(i)
# 1 -2 3 15 5
Range
● Range выдает значения из диапазона с шагом 1.
● Если указано только одно число — от 0 до заданного числа.
● Если нужен другой шаг, третьим аргументов можно задать приращение.
r = range(5) # 0 1 2 3 4
r = range(2, 5) # 2 3 4
r = range(-5, 0) # ----
r = range(1, 10, 2) # 1 3 5 7
r = range(100, 0, -20) # 100 80 60 40 20
r = range(100, 0, -20) # range(100, 0, -20)
for i in r:
print(i)
# 100 80 60 40 20
27
for i in range(5):
print(i)
# 0 1 2 3 4
Можно использовать цикл for() и со строками, так как у строк есть нумерация, такая
же как и у массивов, начинается с 0:
for i in 'qwerty':
print(i)
# q
# w
# e
# r
# t
# y
Можно использовать вложенные циклы:
line = ""
for i in range(5):
line = ""
for j in range(5):
line += "*"
print(line)
'''
#=========================================================
'''
Команды для работы со строками:
text = 'СъЕШЬ ещё этих МяГкИх французских булок'

1. Определить количество символов в строке:
print(len(text)) # 39

2. Проверить наличие символа в строке (in):
print('ещё' in text) # True

3. Функция, которая делает все буквы строки маленькими:
print(text.lower()) # съешь ещё этих мягких французских булок

4. Функция, которая делает все буквы строки большими:
print(text.upper()) # СЪЕШЬ ЕЩЁ ЭТИХ МЯГКИХ ФРАНЦУЗСКИХ БУЛОК

5. Заменить слово на другое :
print(text.replace('ещё','ЕЩЁ')) # СъЕШЬ ЕЩЁ этих МяГкИх французских булок
'''
#=========================================================

# Кортеж — это неизменяемый список. []
# Словари — неупорядоченные коллекции произвольных объектов с доступом по ключу ()

# list_1 = [7, 9, 11, 13, 15, 17]

# В списках существует нумерация, которая начинается с 0, чтобы вывести первый элемент списка воспользуемся следующей конструкцией:
#print(list_1[0]) # 7

# Чтобы узнать количество элементов в списке необходимо использовать функцию len(имя_списка):
#print(len(list_1)) # 6

#=========================================================

# list_1.append()   # сохранение элемента в конец списка
# list_1.pop()   # Метод pop удаляет последний элемент из списка:
# list1.insert(2, 11)  # Функция insert — указание индекса (позиции) и значения. 

#=========================================================

#  list_1 = [12, 7, -1, 21, 0]
#
#  for i in range(len(list_1)):
#       print(list_1[i])     # вывод каждого элемента списка
# или
#
#  for i in range(len(list_1)):
#       print(i)             # вывод каждого элемента списка
#=========================================================

# Можно распаковать кортеж в независимые переменные:
# t = tuple(['red', 'green', 'blue'])
# red, green, blue = t
# print('r:{} g:{} b:{}'.format(red, green, blue)) # или  r:red g:green b:blue

#=========================================================

# dictionary = {}
# dictionary ={'up': '↑', 'left': '←', 'down': '↓', 'right': '→'}
# print(dictionary) # {'up':'↑', 'left':'←', 'down':'↓', 'right':'→'}
# print(dictionary['left']) # ←

# # типы ключей могут отличаться
# print(dictionary['up']) # ↑

# # типы ключей могут отличаться
# dictionary['left'] = '⇐'
# print(dictionary['left']) # ⇐

# del dictionary['left'] # удаление элемента

# for item in dictionary: # for (k,v) in dictionary.items():
#   print('{}: {}'.format(item, dictionary[item]))

# # up: ↑
# # down: ↓
# # right: →
#=========================================================

# my_set = {1, 2, 3}
# my_set.add(4)  # Добавление элемента 4
# print(my_set)  # Вывод: {1, 2, 3, 4}
#=========================================================
# my_set = {1, 2, 3}
# my_set.remove(2)  # Удаление элемента 2
# print(my_set)     # Вывод: {1, 3}
#=========================================================
# my_set = {1, 2, 3}
# my_set.discard(2)  # Удаление элемента 2
# print(my_set)      # Вывод: {1, 3}

# my_set.discard(4)  # Попытка удаления элемента, которого нет в множестве
# print(my_set)      # Вывод: {1, 3} (нет ошибки)
#=========================================================

# Операции со множествами в Python:
# a = {1, 2, 3, 5, 8}
# b = {2, 5, 8, 13, 21}
# c = a.copy() # c = {1, 2, 3, 5, 8}   копирование
# u = a.union(b) # u = {1, 2, 3, 5, 8, 13, 21}  объединение
# i = a.intersection(b) # i = {8, 2, 5}  пересечение
# dl = a.difference(b) # dl = {1, 3}  различие\разность
# dr = b.difference(a) # dr = {13, 21}  различие\разность
# q = a.union(b).difference(a.intersection(b))# {1, 21, 3, 13}   объеденить Б с разницей (А от Б) от пересечения А и Б

#=========================================================

# Неизменяемое или замороженное множество(frozenset) — множество, с которым не будут
# работать методы удаления и добавления.
# a = {1, 2, 3, 5, 8}
# b = frozenset(a)
# print(b) # frozenset({1, 2, 3, 5, 8})

#=========================================================  

#Функция : def

# def sum_numbers(n):
#     summa = 0
#     for  i in range(1, n + 1):
#         summa += i
#     return(summa)  # return Завершает программу и выводит значение
#     #print('stop') --- до принта не дойдет так как см.выше
# print(sum_numbers(5))  
        #или
        # a = sum_numbers(5)
        # print(a)

#========================================================= 

# def sum_str(*arguments):  #звездочка позволяет передавать в функции сколько угодно знаков
#     res = ''
#     for i in arguments:
#         res += i
#     return res

# print(sum_str('a','b','c'))

# print(sum_str('a','b','c','d','e')) #доступно увеличение аргументов так как в ф-ции "*"

# def sum_int(*n):   #звездочка работает с int
#     res = 0
#     for i in n:
#         res += i
#     return res
# print(sum_int(1,10,2))

#========================================================= 

# def max1(a,b):
#     if a > b:
#         return a
#     #  else можно не писать, достаточно ретурнов
#     #  else: return b
#     return b

# print(max1(2,3))

#========================================================= 
#импорт функции из другого файла            

# import modul1 (файл модуль один точка пу)   # #from modul1 import *  импорт всех функций      # import modul1  as m1   

# print(modul1.max1(5,9))                            # print(modul1.max1(5,9))                  # print(modul1.m1(5,9))                                         

#========================================================= 

#рекурсия фибоначчи

# def fib(n):
#     if n in [1, 2]:             #важно делать выход из рекурсии 
#         return 1
#     return fib(n - 1) + fib(n - 2)


# list_1 = []
# for i in range(1, 10):
#     list_1.append(fib(i))
# print(list_1)    

#========================================================= 

# быстрая сортировка

# def quick_sort(array):
#     if len(array) <= 1:
#         return array
#     else: 
#         pivot = array[0] #  pivot - первый элемент, с кот. идет сравнение 
#                          #  и дальнейшая разбивка на 2 списка less и greater

#     less = [i for i in array[1:] if i <= pivot] #все элементы после первого, добавляя только >= pivot    
#     greater = [i for i in array[1:] if i > pivot] #все элементы после первого, добавляя только < pivot
#     return quick_sort(less) + [pivot] + quick_sort(greater)

# print(quick_sort([10,5,2]))

# ● 1-е повторение рекурсии:
#   ○ array = [10, 5, 2, 3]
#   ○ pivot = 10
#   ○ less = [5, 2, 3]
#   ○ greater = []
#   ○ return quicksort([5, 2, 3]) + [10] + quicksort([])

# ● 2-е повторение рекурсии:
#   ○ array = [5, 2, 3]
#   ○ pivot = 5
#   ○ less = [2, 3]
#   ○ greater = []
#   ○ return quicksort([2, 3]) + [5] + quicksort([]) 
# 
# # Важно! Не забывайте, что здесь помимо вызова рекурсии добавляется список [10]

# ● 3-е повторение рекурсии:
#   ○ array = [2, 3]
#   ○ return [2, 3]     
# 
# # Сработал базовый случай рекурсии
#  На этом работа рекурсии завершилась и итоговый список будет выглядеть таким образом: 
# [2, 3] + [5] + [10] = [2, 3, 5, 10]

#========================================================= 

# #Сортировка слиянием
# def merge_sort(numbers):
#     if len(numbers) > 1:
#         mid = len(numbers) // 2 # деление списка на двое
#         left = numbers[:mid]  # от начала до середины
#         right = numbers[mid:]  # от серидины до конца
#         merge_sort(left)
#         merge_sort(right)
#         i = j = k = 0
#         while i < len(left) and j < len(right):
#             if left[i] < right[j]:
#                 numbers[k] = left[i]
#                 i += 1
#             else: 
#                 numbers[k] = right[j]
#                 j += 1
#             k += 1
        
#         while i < len(left):
#             numbers[k] = left[i]
#             i += 1
#             k += 1

#         while j < len(right):
#             numbers[k] = right[j]
#             j += 1
#             k += 1

# list_1 = [1,5,6,7,8,2,4,66,7,87,2,0,21]
# merge_sort(list_1)
# print(list_1)

#========================================================= 